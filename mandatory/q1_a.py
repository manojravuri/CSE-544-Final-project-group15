# -*- coding: utf-8 -*-
"""q1_a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16FWq_HSqvi5D9vVZhVx3prX0wEYuys0W
"""

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd gdrive/MyDrive/probstat

# Commented out IPython magic to ensure Python compatibility.
# %pwd

import pandas as pd
import numpy as np

def get_beta(train_x, train_y):
    train_x_transpose = np.transpose(train_x)
    #find the transpose of X
    x_x_t = np.matmul(train_x_transpose, train_x)
    #We know B= x^-1*X*Y
    beta = np.matmul(np.matmul(np.linalg.inv(x_x_t), train_x_transpose), train_y)
    return beta

"""The above function is used for finding the beta values from the x and y values"""

def pad_one(x):
    y=np.array([1])
    y=np.append(y,x)
    return y

"""The above function is used to append 1 to the begining of an array for the constant beta term"""

def get_regression_data(x, p):
    n = x.size
    #create a matrix with all zeros
    x_data_without_ones = np.ones((n - p, p))
    x_data = np.ones((n - p, p+1))
    y_data = np.ones(n - p)
    #get p values for each row
    for i in range(p, n):
        y_data[i - p] = x[i]
        #pad zeros for constant beta term
        x_data_without_ones[i - p, :] = np.reshape(x[i - p:i], (1, p))
        x_data[i - p, :] = pad_one(x_data_without_ones[i - p, :])
    return x_data, y_data

"""The above function is used to get the time series data for the past p days and the predicted value on the p+1 day"""

def AR(x, p):
    print("AR("+str(p)+")")
    x_three = x[70:91]
    x_four = x[91:100]
    n = x_four.size
    mape = 0
    mse = 0
    #change the input data based on the value of p.i.e, if p=3 then three consucitive records are taken
    x_data, y_data = get_regression_data(x[70:100], p)
    for i in range(n - 1):
        #Beta values are calculated by appending 1 to each row and doing the matrix inverse
        #beta is calculated at each stage
        beta = get_beta(x_data[0:21 + i - p, :], y_data[0:21 - p + i])
        #find the predicted array
        pred = beta * x_data[21 + i - p + 1, :]
        #find the predicted value
        pred = np.sum(pred)
        # if the denominator is zeo in the MAPE calculation changed the denominator to 1
        if (x_four[i] == 0):
            mape = mape + abs((x_four[i] - pred))
        else:
            mape = mape + abs((x_four[i] - pred) / x_four[i])
        mse = mse + ((x_four[i] - pred) * (x_four[i] - pred))
    mape = 100 / n * (mape)
    mse = mse / n
    print("Mean Absolute Percentage Error", mape)
    print("Mean Squared error", mse)
    return mape, mse

"""

*  The above function is used to find the predicted value using auto regression method.
*   The metrics are calculated after the each prediction and the final metrics are printed


"""

def get_predicted_value(x, alpha):
    #x is the data of the last p-1 days
    n = x.size
    rev_alpha = 1 - alpha
    coeff = 1
    pred = 0
    # when we expand the EWMA we get the below coefficients for each term
    for i in range(n):
        pred = pred + (x[n - i - 1] * (coeff))
        coeff = coeff * rev_alpha
    pred = pred * alpha
    #return the predicted value on the pth day
    return pred

"""Get the pth day predicted value based on the alpha and previous p-1 days data """

def EWMA(x, alpha):
    print("EWMA("+str(alpha)+")")
    #x_three is the data of the first weeks
    x_three = x[70:91]
    #x_four is the data of the fourth week
    x_four = x[91:100]
    #number of predicted days in the fourth week
    n=x_four.size
    mse = 0
    mape = 0
    for i in range(n):
        #get the predicted value on t-day from t-1 days data
        #t-1 days data is passed at each iteration
        pred = get_predicted_value(x[70:91 + i], alpha)
        #if the denominator is zeo in the MAPE calculation changed the denominator to 1
        if(x_four[i]==0):
            mape = mape + abs((x_four[i] - pred))
        else:
            mape = mape + abs((x_four[i] - pred) / x_four[i])
        mse = mse + ((x_four[i] - pred) * (x_four[i] - pred))
    mape = (100 / n) * (mape)
    mse = mse / n
    print("Mean Absolute Percentage Error", mape)
    print("Mean Squared error", mse)
    return mape, mse

"""Perform EWMA on the data to find the predicted value of the fourth week based on the data of the data before the current day"""

def run_all_models(x):
    #Autoregressive model with p
    AR(x, 3)
    AR(x, 5)

    #Exponential weighted moving average with alpha
    EWMA(x, 0.5)
    EWMA(x, 0.8)

"""Run all the models with the parameters for an attribute"""

def q1_a():
    #get the data from the file
    dataframe = pd.read_csv('../15_updated.csv')
    ne_confirmed = dataframe['ne_confirmed_per_day'].to_numpy()
    nd_confirmed = dataframe['nd_confirmed_per_day'].to_numpy()
    ne_deaths = dataframe['ne_deaths_per_day'].to_numpy()
    nd_deaths = dataframe['nd_deaths_per_day'].to_numpy()


    print("NE Confirmed")
    run_all_models(ne_confirmed)
    print("ND Confirmed")
    run_all_models(nd_confirmed)
    print("NE Deaths")
    run_all_models(ne_deaths)
    print("ND Deaths")
    run_all_models(nd_deaths)

q1_a()